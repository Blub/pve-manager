#!/usr/bin/perl -w

use strict;

use PVE::Tools qw(extract_param);
use PVE::Cluster qw(cfs_register_file cfs_read_file);
use PVE::SafeSyslog;
use PVE::INotify;
use PVE::RPCEnvironment;
use PVE::CLIHandler;
use PVE::API2::OpenVZ;

use Data::Dumper; # fixme: remove

use base qw(PVE::CLIHandler);

$ENV{'PATH'} = '/sbin:/bin:/usr/sbin:/usr/bin';

initlog('pvectl');

die "please run as root\n" if $> != 0;

PVE::INotify::inotify_init();
my $nodename = PVE::INotify::nodename();

my $rpcenv = PVE::RPCEnvironment->init('cli');

$rpcenv->init_request();
$rpcenv->set_language($ENV{LANG});
$rpcenv->set_user('root@pam'); 

my $upid_exit = sub {
    my $upid = shift;
    my $status = PVE::Tools::upid_read_status($upid);
    exit($status eq 'OK' ? 0 : -1);
};

__PACKAGE__->register_method ({
    name => 'startall', 
    path => 'startall', 
    method => 'POST',
    description => "Start all containers (when onboot=1).",
    parameters => {
    	additionalProperties => 0,
	properties => {},
    },
    returns => { type => 'null'},
    code => sub {
	my ($param) = @_;

	# wait up to 10 seconds for quorum
	for (my $i = 10; $i >= 0; $i--) {
	    last if PVE::Cluster::check_cfs_quorum($i != 0 ? 1 : 0);
	    sleep(1);
	}
	
	my $vzlist = PVE::OpenVZ::vmstatus();

	my $cc = PVE::Cluster::cfs_read_file('cluster.conf');

	my $startList = {};
	foreach my $vmid (keys %$vzlist) {
	    next if $vzlist->{$vmid}->{status} eq 'running'; # already running

	    my $conf;
	    eval { $conf = PVE::OpenVZ::load_config($vmid); };
	    if (my $err = $@) {
		warn $err;
		next;
	    }

	    next if !$conf;

	    next if !($conf->{onboot} && $conf->{onboot}->{value});

	    # skip ha managed VMs (started by rgmanager)
	    next if PVE::Cluster::cluster_conf_lookup_pvevm($cc, 0, $vmid, 1);

	    if ($conf->{bootorder} && defined($conf->{bootorder}->{value})) {
		$vzlist->{$vmid}->{bootorder} = $conf->{bootorder}->{value};
	    } else {
		$vzlist->{$vmid}->{bootorder} = -1000000000;
	    }
	    
	    $startList->{$vmid} = $vzlist->{$vmid};
	}

	foreach my $vmid (sort {
	    return $a <=> $b if $startList->{$b}->{bootorder} == $startList->{$a}->{bootorder};
	    return $startList->{$b}->{bootorder} <=> $startList->{$a}->{bootorder};
	    } keys %$startList) {

	    PVE::Cluster::check_cfs_quorum(); # abort when we loose quorum

	    eval {
		print STDERR "Starting CT $vmid\n";
		PVE::API2::OpenVZ->vm_start({node => $nodename, vmid => $vmid });
	    };
	    warn $@ if $@;
	}

	return undef;
    }});

__PACKAGE__->register_method ({
    name => 'stopall', 
    path => 'stopall', 
    method => 'POST',
    description => "Stop all containers.",
    parameters => {
    	additionalProperties => 0,
	properties => {
	    timeout => {
		description => "Wait maximal timeout seconds.",
		type => 'integer',
		minimum => 0,
		optional => 1,
		default => 60,
	    },
	},
    },
    returns => { type => 'null'},
    code => sub {
	my ($param) = @_;

	my $vzlist = PVE::OpenVZ::vmstatus();
	my $timeout = defined ($param->{timeout}) ? $param->{timeout} : 60;

	syslog('info', "Stopping all Container");

	foreach my $vmid (keys %$vzlist) {
	    next if $vzlist->{$vmid}->{status} ne 'running'; # not running

	    eval {
		print STDERR "Stoping CT $vmid\n";

		# Set fairsched parameters to maximum so CT will stop fast
		# ignore any errors
		system("vzctl set $vmid --cpuunits 2000 --cpulimit 0 >/dev/null 2>&1");

		PVE::API2::OpenVZ->vm_shutdown({node => $nodename, vmid => $vmid, 
						timeout => $timeout, forceStop => 1 });
	    };
	    warn $@ if $@;
	}

	return undef;
    }});

my $cmddef = {

    list => [ "PVE::API2::OpenVZ", 'vmlist', [],
	     { node => $nodename }, sub {
		 my $vmlist = shift;

		 exit 0 if (!scalar(@$vmlist));

		 printf "%10s %-20s %-10s %-10s %-12s %-10s\n", 
		 qw(VMID NAME STATUS MEM(MB)  DISK(GB));

		 foreach my $rec (sort { $a->{vmid} <=> $b->{vmid} } @$vmlist) {
		     printf "%10s %-20s %-10s %-10s %-12.2f\n", $rec->{vmid}, $rec->{name} || '', 
		     $rec->{status}, 
		     ($rec->{maxmem} || 0)/(1024*1024), 
		     ($rec->{maxdisk} || 0)/(1024*1024*1024);
		 }		 
	      } ],

    create => [ 'PVE::API2::OpenVZ', 'create_vm', ['vmid', 'ostemplate'], { node => $nodename }, $upid_exit ],
    destroy => [ 'PVE::API2::OpenVZ', 'destroy_vm', ['vmid'], { node => $nodename }, $upid_exit ],

    set => [ "PVE::API2::OpenVZ", 'update_vm', ['vmid'], { node => $nodename } ],

    config => [ "PVE::API2::OpenVZ", 'vm_config', ['vmid'], 
		{ node => $nodename }, sub {
		    my $config = shift;
		    foreach my $k (sort (keys %$config)) {
			next if $k eq 'digest';
			my $v = $config->{$k};
			if ($k eq 'description') {
			    $v = PVE::Tools::encode_text($v);
			}
			print "$k: $v\n";
		    }
		}],

    start => [ 'PVE::API2::OpenVZ', 'vm_start', ['vmid'], { node => $nodename }, $upid_exit],
    shutdown => [ 'PVE::API2::OpenVZ', 'vm_shutdown', ['vmid'], { node => $nodename }, $upid_exit],
    stop => [ 'PVE::API2::OpenVZ', 'vm_stop', ['vmid'], { node => $nodename }, $upid_exit],
    mount => [ 'PVE::API2::OpenVZ', 'vm_mount', ['vmid'], { node => $nodename }, $upid_exit],
    umount => [ 'PVE::API2::OpenVZ', 'vm_umount', ['vmid'], { node => $nodename }, $upid_exit],
    migrate => [ "PVE::API2::OpenVZ", 'migrate_vm', ['vmid', 'target'], { node => $nodename }, $upid_exit],

    startall => [ __PACKAGE__, 'startall', []],
    stopall => [ __PACKAGE__, 'stopall', []],
};

my $cmd = shift;

PVE::CLIHandler::handle_cmd($cmddef, "pvectl", $cmd, \@ARGV, undef, $0);

exit 0;

__END__

=head1 NAME

pvectl - vzctl wrapper to manage OpenVZ containers

=head1 SYNOPSIS

=include synopsis

=head1 DESCRIPTION

This is a small wrapper around vztl.

=include pve_copyright
